#chan
//这里的s 相当于 <- strings，只有赋值之后才能读取到，否则一直阻塞
strings := make(chan string)
for s := range strings {
}

#
struch{}代表不包含任何字段的结构体类型，也可称为空结构体类型。在go语言中，空结构体类型是不占用系统内存的，并且所有该类型的变量都拥有相同的内存地址。
建议用于传递信号的通道都以struct{}作为元素类型，除非需要传递更多的信息

#
syncChan1 := make(chan struct{},1)  //接收同步变量  
syncChan2 := make(chan struct{},2) //主线程启动了两个goruntime线程，
<- syncChan1  //表示可以开始接收数据了，否则等待
syncChan1 <- struct{}{}  //发送操作

#//主线程等待发送线程和接收线程结束后再结束
#https://blog.csdn.net/qq_25392761/article/details/80206796
go func(){
syncChan2 <- struct{}{}
}()
<- syncChan2

#内建函数len和cap可用于通道之上。len表示获取通道中当前元素的数量，cap表示获取通道的容量。
通道的长度随着通道中拥有的元素数量而变化，而通道的容量是在初始化的时候确定的，之后不会再修改

#chan引用传递
上述代码通道中传递的是map类型，属于引用类型，因此接收方对元素值得修改会影响到发送方持有的值
调用close可以关闭通道。注意：师徒向一个已经关闭的通道发送元素值，会让发送操作引发运行时恐慌。因此一定要在确保安全的前提下关闭通道。
无论怎么样都不应该在接收端关闭通道。因为在接收端通常无法判断发送端是否还会向该通道发送元素值。
在发送端关闭通道不会对接收端的接收操作产生什么影响。如果通道在被关闭时其中仍有元素值，接收端仍然可以接收，病根据接收表达式的第二个结果值判断通道是否关闭或者是否有元素可取
内建函数len和cap可用于通道之上。len表示获取通道中当前元素的数量，cap表示获取通道的容量。通道的长度随着通道中拥有的元素数量而变化，而通道的容量是在初始化的时候确定的，之后不会再修改


#for语句与channel
当定义chan大小为1时，容量为1，表示缓冲大小为1；当定义chan大小为0时，容量为0，表示该通道没有缓冲区，发送方发送一个值后需要等待接收方接收才可以发送下一个值
for语句中可以使用range子句从通道中持续不断地接收数据。当通道还未被初始化或者通道中没有任何元素时，for语句所在的goruntime会陷入阻塞，阻塞的具体位置在其中的range子句处。for语句会不断地尝试从通道中接收元素，直到该通道关闭
